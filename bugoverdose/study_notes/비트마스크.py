# 이진수의 값으로서 사용하는 것이 아니라 참/불의 집합으로서 활용 => 메모리/성능 개선
switch_states = [True, False, False, True, True, False, False, False, True, True]
switch_states = 0b1001100011

# AND 연산(교집합) : A & B 
# 대응하는 숫자가 모두 1일 경우 1을 반환합니다.
bin(0b1010011010 & 0b1101101100)  # 0b1000001000

# OR 연산(합집합) : A | B
# 대응하는 숫자중 하나라도 1일 경우 1을 반환합니다.
bin(0b1010011010 | 0b1101101100)  # 0b1111111110

# XOR 연산 : A ^ B
# 대응하는 숫자가 서로 다를 경우 1을 반환합니다.
bin(0b1010011010 ^ 0b1101101100)  # 0b111110110

# SHIFT 연산 (>>, <<) : 2로 곱하거나 나눔
# a << b는 a의 비트를 b칸 만큼 왼쪽으로 밀어 내는 것이고, a >> b는 a의 비트를 b칸 만큼 오른쪽으로 밀어내는 것 입니다.
bin(0b0010 << 2)  # 0b1000 # 2*4 = 8
bin(0b1100 >> 2)  # 0b11   # 12//4 = 3 

# NOT 연산 (~) : 비트 값을 반전시킵니다. 
bin(~0b0010 << 2)  # 0b1101

print(0b0010)       # 2
print(~0b0010)      # -3 : -3, -2, -1 | 0, 1, 2
print(~0b0010 << 2) # -12

print(0b1101)  # 13
print(~0b1101) # -14
print(~0b1101 + 0b0001) # -13

# ====================================================================
# 비트 연산 응용
# 주의 bin()은 이진수 형식으로 변환된 '문자열 값'을 반환

# 원소 추가 : n번째 수를 추가 하고자 할 때
n = 3
print(bin(0b0010 | (1 << n)))  #  0b1010

# 원소 제거 : n번째 수를 제거 하고자 할 때
n = 3
print(bin(0b1010 & ~(1 << n)))  #  0b10

# 원소 조회 : n번째 수가 있나 없나 확인 할 때 (0이면 없고, 1 이상이면 있는 것)
n = 3
print(bin(0b1010 & (1 << n)))  #  0b1000

# 원소 토글 : n번째 수를 켜져 있으면 끄고, 꺼져 있으면 켬
n = 3
print(bin(0b1010 ^ (1 << n)))  #  0b10

# ====================================================================